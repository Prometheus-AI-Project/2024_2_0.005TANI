# -*- coding: utf-8 -*-
"""inference.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vrhoqMgvRHUqaHHUBKzst1pEYkgrWwza
"""

!pip install tensorflow
import os
import numpy as np
from tensorflow import keras
from tensorflow.keras.models import load_model

import numpy as np
import pickle
from tensorflow.keras.models import load_model
import tensorflow as tf

# -----------------------------
# (1) custom_objects 설정
# -----------------------------
custom_objects = {'mse': tf.keras.losses.MeanSquaredError()}

# -----------------------------
# (2) 체크포인트(모델) 파일 경로
# -----------------------------
checkpoint_pitchtype = "Pitchtype_checkpoint.h5"
checkpoint_pitcher   = "Pitcher_checkpoint.h5"
checkpoint_runner    = "Runner_checkpoint.h5"
checkpoint_ballcount = "BallCount_checkpoint.h5"

# -----------------------------
# (3) 모델 로드
# -----------------------------
model_1 = load_model(checkpoint_pitchtype, custom_objects=custom_objects)
model_2 = load_model(checkpoint_pitcher,   custom_objects=custom_objects)
model_3 = load_model(checkpoint_runner,    custom_objects=custom_objects)
model_4 = load_model(checkpoint_ballcount, custom_objects=custom_objects)

# -----------------------------
# (4) 스케일러 로드
# -----------------------------
with open('scaler_X_pitchtype.pkl', 'rb') as f:
    scaler_X_1 = pickle.load(f)
with open('scaler_X_pitcher.pkl', 'rb') as f:
    scaler_X_2 = pickle.load(f)
with open('scaler_X_runner.pkl', 'rb') as f:
    scaler_X_3 = pickle.load(f)
with open('scaler_X_ballcount.pkl', 'rb') as f:
    scaler_X_4 = pickle.load(f)

# -----------------------------
# (5) 예시 입력 데이터
# -----------------------------
# 여기서 rh, lh 대신 hand라는 단일 변수만 사용한다고 가정
# 예: hand = 1이면 오른손잡이, 0이면 왼손잡이
input_dict = {
    "height": 180,
    "hand": 1,  # 1 = R, 0 = L (예시)
    "pitch_type(0-7)": 2,
    "pitch_mechanic": 1,
    "is_runner": 0,
    "ballcount" : 1
}

# -----------------------------
# (6) 모델별 사용 피처 지정
# -----------------------------
# 기존에 ["height", "rh", "lh", ...] 식으로 구성되어 있었다면,
# 이제 "hand"만 단일 컬럼으로 바꿔준다.
input_cols_1 = ["height", "hand", "pitch_type(0-7)"]
input_cols_2 = ["height", "hand", "pitch_mechanic"]
input_cols_3 = ["height", "hand", "is_runner"]
input_cols_4 = ["height", "hand", "ballcount"]

# zone 이름
zone_cols = [f"zone{i}" for i in range(1, 26)]

# -----------------------------
# (7) 단일 샘플 예측 함수
# -----------------------------
def predict_zones_single_sample(model, scaler_X, input_dict, input_cols):
    # 입력 칼럼에 해당하는 값들을 순서대로 가져옴
    x_list = [input_dict[col] for col in input_cols]
    x_array = np.array(x_list).reshape(1, -1)

    # 스케일링
    x_scaled = scaler_X.transform(x_array)

    # 모델 예측 (출력 차원은 (1, 25)라고 가정)
    y_pred = model.predict(x_scaled)
    return y_pred.flatten()  # (25,)

# -----------------------------
# (8) 모델별 예측 수행
# -----------------------------
preds = []

y_pred_1 = predict_zones_single_sample(
    model=model_1,
    scaler_X=scaler_X_1,
    input_dict=input_dict,
    input_cols=input_cols_1
)
preds.append(y_pred_1)

y_pred_2 = predict_zones_single_sample(
    model=model_2,
    scaler_X=scaler_X_2,
    input_dict=input_dict,
    input_cols=input_cols_2
)
preds.append(y_pred_2)

y_pred_3 = predict_zones_single_sample(
    model=model_3,
    scaler_X=scaler_X_3,
    input_dict=input_dict,
    input_cols=input_cols_3
)
preds.append(y_pred_3)

y_pred_4 = predict_zones_single_sample(
    model=model_4,
    scaler_X=scaler_X_4,
    input_dict=input_dict,
    input_cols=input_cols_4
)
preds.append(y_pred_4)

preds = np.array(preds)  # shape: (4, 25)

# -----------------------------
# (9) 결과 출력
# -----------------------------
print("===== 4개 모델 각각의 zone 예측(확률/점수) =====")
for i, pred in enumerate(preds, start=1):
    print(f"\n[Model {i}]")
    for zone_idx, zone_val in enumerate(pred):
        print(f"{zone_cols[zone_idx]}: {zone_val:.4f}")

# -----------------------------
# (10) 모델들의 예측 결과 평균
# -----------------------------
avg_pred = preds.mean(axis=0)  # (25,)
print("\n===== 4개 모델 평균 zone 예측(확률/점수) =====")
for zone_idx, zone_val in enumerate(avg_pred):
    print(f"{zone_cols[zone_idx]}: {zone_val:.4f}")

# 상위 3개 zone
top_3_indices = np.argsort(avg_pred)[-3:][::-1]
print("\n===== 가장 확률(점수)이 높은 3개 zone =====")
for idx in top_3_indices:
    print(f"{zone_cols[idx]}: {avg_pred[idx]:.4f}")
###############
#연결 출루율 모델
################

import numpy as np
import pickle
from tensorflow.keras.models import load_model
import tensorflow as tf

# -----------------------------
# (1) custom_objects 설정
# -----------------------------
custom_objects = {'mse': tf.keras.losses.MeanSquaredError()}

# -----------------------------
# (2) 체크포인트(모델) 파일 경로
# -----------------------------
checkpoint_hitter    = "hitter_lh_or_rh_checkpoint.h5"
checkpoint_ballcount = "hitter_BallCount_checkpoint.h5"
checkpoint_runner   = "hitter_runner_checkpoint.h5"

# -----------------------------
# (3) 모델 로드
# -----------------------------
model_5 = load_model(checkpoint_ballcount, custom_objects=custom_objects)
model_6 = load_model(checkpoint_hitter,   custom_objects=custom_objects)
model_7 = load_model(checkpoint_runner,    custom_objects=custom_objects)

# -----------------------------
# (4) 스케일러 로드
# -----------------------------
with open('scaler_X_hit_ballcount.pkl', 'rb') as f:
    scaler_X_5 = pickle.load(f)
with open('scaler_X_hit_lh_or_rh.pkl', 'rb') as f:
    scaler_X_6 = pickle.load(f)
with open('scaler_X_hit_runner.pkl', 'rb') as f:
    scaler_X_7 = pickle.load(f)

# -----------------------------
# (5) 예시 입력 데이터
# -----------------------------
# 여기서 rh, lh 대신 hand라는 단일 변수만 사용한다고 가정
# 예: hand = 1이면 오른손잡이, 0이면 왼손잡이
input_dict = {
    "height": 180,
    "lp_or_rp": 1,  # 1 = R, 0 = L (예시)
    "pitch_mechanic": 1,
    "lh_or_rh" : 0,
    "is_runner": 0,
    "ballcount" : 1
}

# -----------------------------
# (6) 모델별 사용 피처 지정
# -----------------------------
# 기존에 ["height", "rh", "lh", ...] 식으로 구성되어 있었다면,
# 이제 "hand"만 단일 컬럼으로 바꿔준다.
input_cols_5 = ["height", "lp_or_rp", "pitch_mechanic","ballcount" ]
input_cols_6 = ["height", "lp_or_rp", "pitch_mechanic","lh_or_rh"]
input_cols_7 = ["height", "lp_or_rp", "pitch_mechanic","ballcount"]

# zone 이름
zone_cols = [f"zone{i}" for i in range(1, 26)]

# -----------------------------
# (7) 단일 샘플 예측 함수
# -----------------------------
def predict_zones_single_sample(model, scaler_X, input_dict, input_cols):
    # 입력 칼럼에 해당하는 값들을 순서대로 가져옴
    x_list = [input_dict[col] for col in input_cols]
    x_array = np.array(x_list).reshape(1, -1)

    # 스케일링
    x_scaled = scaler_X.transform(x_array)

    # 모델 예측 (출력 차원은 (1, 25)라고 가정)
    y_pred = model.predict(x_scaled)
    return y_pred.flatten()  # (25,)

# -----------------------------
# (8) 모델별 예측 수행
# -----------------------------
preds = []

y_pred_5 = predict_zones_single_sample(
    model=model_5,
    scaler_X=scaler_X_5,
    input_dict=input_dict,
    input_cols=input_cols_5
)
preds.append(y_pred_5)

y_pred_6 = predict_zones_single_sample(
    model=model_6,
    scaler_X=scaler_X_6,
    input_dict=input_dict,
    input_cols=input_cols_6
)
preds.append(y_pred_6)

y_pred_7 = predict_zones_single_sample(
    model=model_7,
    scaler_X=scaler_X_7,
    input_dict=input_dict,
    input_cols=input_cols_7
)
preds.append(y_pred_7)


preds = np.array(preds)  # shape: (4, 25)

# -----------------------------
# (9) 결과 출력
# -----------------------------
print("===== 3개 모델 각각의 zone 예측(확률/점수) =====")
for i, pred in enumerate(preds, start=1):
    print(f"\n[Model {i}]")
    for zone_idx, zone_val in enumerate(pred):
        print(f"{zone_cols[zone_idx]}: {zone_val:.4f}")

# -----------------------------
# (10) 모델들의 예측 결과 평균
# -----------------------------
avg_pred = preds.mean(axis=0)  # (25,)

sum_val = avg_pred.sum()

# 2) 각 값을 (sum_val 대비) 퍼센트로 환산 * 100
pct_vals = (avg_pred / sum_val) * 100

# 3) 소수점 둘째 자리로 일괄 반올림
pct_vals_2dec = np.round(pct_vals, 2)

# 4) 반올림 후 발생하는 오차를 보정해 합을 정확히 100.00으로 맞춤
#    - 예: 2번째 자리로 반올림 후 합이 99.98이면 remainder=0.02
remainder = 100.0 - pct_vals_2dec.sum()

# 5) 가장 큰 값(가장 높은 퍼센트)에 remainder를 더해 합을 맞춤
max_idx = np.argmax(pct_vals_2dec)
pct_vals_2dec[max_idx] += remainder

# (주의) 다시 반올림하면 합이 미세하게 달라질 수 있으므로
#       여기서는 그대로 두고, 최종 출력 시 포매팅을 통해 2자리 표현

# 결과 출력
print("\n===== 3개 모델 평균 zone 예측(퍼센트) =====")
for zone_idx, zone_val in enumerate(pct_vals_2dec):
    print(f"{zone_cols[zone_idx]}: {zone_val:.2f}")

print(f"\nSum of all zones = {pct_vals_2dec.sum():.2f}")

# 상위 3개 zone
top_3_indices = np.argsort(avg_pred)[-3:][::-1]
print("\n===== 가장 확률(점수)이 높은 3개 zone =====")
for idx in top_3_indices:
    print(f"{zone_cols[idx]}: {avg_pred[idx]:.4f}")
###############
#연결 출루율 모델
################

########
#example output
########

"""
[Model 1]
zone1:
zone2:
...
zone25:

"""
"""
zone17:
zone9 :
zone25:
"""

"""본격적 부가 시현 모델

"""

import numpy as np

NUM_ZONES = 25
STRIKE_ZONES = {7, 8, 9, 12, 13, 14, 17, 18, 19}

def get_adjacent_zones(zone_id):
    idx = zone_id - 1
    row, col = divmod(idx, 5)
    neighbors = []
    if row - 1 >= 0:
        neighbors.append((row - 1)*5 + col + 1)
    if row + 1 < 5:
        neighbors.append((row + 1)*5 + col + 1)
    if col - 1 >= 0:
        neighbors.append(row*5 + (col - 1) + 1)
    if col + 1 < 5:
        neighbors.append(row*5 + (col + 1) + 1)
    return neighbors

def get_top3_zones(prob_array):
    top3_idx = np.argsort(prob_array)[-3:][::-1]
    return [i+1 for i in top3_idx]

def advance_runners(base_state, hit_type, runs_scored):
    on1, on2, on3 = base_state
    if hit_type == "walk":
        if on3:
            runs_scored += 1
        on3_new = on2 or False
        on2_new = on1 or False
        on1_new = True
        return [on1_new, on2_new, on3_new], runs_scored
    elif hit_type == "single":
        if on3:
            runs_scored += 1
        on3_new = on2
        on2_new = on1
        on1_new = True
        return [on1_new, on2_new, on3_new], runs_scored
    elif hit_type == "double":
        if on3:
            runs_scored += 1
        if on2:
            runs_scored += 1
        on3_new = on1
        on2_new = True
        on1_new = False
        return [on1_new, on2_new, on3_new], runs_scored
    elif hit_type == "homerun":
        run_count = (1 if on1 else 0) + (1 if on2 else 0) + (1 if on3 else 0) + 1
        runs_scored += run_count
        return [False, False, False], runs_scored
    return base_state, runs_scored

def process_pitch(pitch_zone, aim_zone, strike_count, ball_count, out_count, base_state, runs_scored):
    result_msg = ""
    hit_type = None
    if aim_zone is None:
        if pitch_zone in STRIKE_ZONES:
            strike_count += 1
            result_msg = f"관망 → 스트라이크(zone{pitch_zone}) (S={strike_count})"
        else:
            ball_count += 1
            if ball_count >= 4:
                hit_type = "walk"
                base_state, runs_scored = advance_runners(base_state, hit_type, runs_scored)
                result_msg = "볼4개 → 워크(Walk) 발생!"
                strike_count = 0
                ball_count = 0
            else:
                result_msg = f"관망 → 볼(zone{pitch_zone}) (B={ball_count})"
    else:
        if (pitch_zone in STRIKE_ZONES) and (aim_zone == pitch_zone):
            hit_type = "homerun"
            base_state, runs_scored = advance_runners(base_state, hit_type, runs_scored)
            result_msg = f"★ 홈런! (pitch={pitch_zone}, aim={aim_zone})"
            strike_count = 0
            ball_count = 0
        elif (pitch_zone in STRIKE_ZONES) and (aim_zone in STRIKE_ZONES):
            if aim_zone in get_adjacent_zones(pitch_zone):
                hit_type = "double"
                base_state, runs_scored = advance_runners(base_state, hit_type, runs_scored)
                result_msg = f"★ 2루타(Double)! (pitch={pitch_zone}, aim={aim_zone})"
                strike_count = 0
                ball_count = 0
            else:
                strike_count += 1
                result_msg = f"헛스윙! (pitch={pitch_zone}, aim={aim_zone}) 스트 {strike_count}"
        elif (pitch_zone not in STRIKE_ZONES):
            if aim_zone in get_adjacent_zones(pitch_zone):
                hit_type = "single"
                base_state, runs_scored = advance_runners(base_state, hit_type, runs_scored)
                result_msg = f"★ 1루타(Single)! (pitch={pitch_zone}, aim={aim_zone})"
                strike_count = 0
                ball_count = 0
            else:
                strike_count += 1
                result_msg = f"헛스윙! (pitch={pitch_zone}, aim={aim_zone}) 스트 {strike_count}"
        else:
            strike_count += 1
            result_msg = f"헛스윙! (pitch={pitch_zone}, aim={aim_zone}) 스트 {strike_count}"
    if strike_count >= 3:
        out_count += 1
        result_msg += f" => 삼진 아웃! (Out={out_count})"
        strike_count = 0
        ball_count = 0
    return strike_count, ball_count, out_count, base_state, runs_scored, result_msg
def predict_next_zone():
    """여기에 '4개 모델로부터 zone 예측' 로직을 구현할 수 있음."""
    preds = np.random.rand(4, 25)         # 예시: 랜덤
    avg_pred = preds.mean(axis=0)
    best_zone = np.argmax(avg_pred) + 1   # 1~25
    return best_zone

def main_game_sim():
    inning = 1
    total_runs = 0
    while True:
        print(f"--- {inning} 이닝 시작 ---")
        strike_count = 0
        ball_count = 0
        out_count = 0
        base_state = [False, False, False]
        inning_runs = 0
        while out_count < 3:
            avg_pred_new = np.random.rand(NUM_ZONES)
            avg_pred_new = avg_pred_new / avg_pred_new.sum()
            pitch_zone_in = input("투수 존(1~25) 입력 (종료:q): ")
            if pitch_zone_in.lower() == 'q':
                print("사용자 종료")
                return
            pitch_zone = predict_next_zone()
            top3 = get_top3_zones(avg_pred_new)
            aim_zone = None
            for z in top3:
                if z in STRIKE_ZONES:
                    aim_zone = z
                    break
            bs, bb, bo = strike_count, ball_count, out_count
            bstate_before = base_state[:]
            strike_count, ball_count, out_count, base_state, inning_runs, msg = process_pitch(
                pitch_zone, aim_zone, strike_count, ball_count, out_count, base_state, inning_runs
            )
            on1, on2, on3 = base_state
            print(f"투구존={pitch_zone}, Top3={top3}, 스윙존={aim_zone}, (S,B,O)=({bs},{bb},{bo}) => {msg}")
            print(f"주자상황=[1루:{on1}, 2루:{on2}, 3루:{on3}], 이닝득점={inning_runs}, 총득점={total_runs+inning_runs}")
            print(f"(현재 Strike={strike_count}, Ball={ball_count}, Out={out_count})\n")
            if out_count >= 3:
                print(f"--- {inning} 이닝 종료! 이닝 득점: {inning_runs} ---\n")
                total_runs += inning_runs
                break
        inning += 1

if __name__ == "__main__":
    main_game_sim()

